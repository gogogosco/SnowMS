/*
This file is part of the OdinMS Maple Story Server
Copyright (C) 2008 Patrick Huy <patrick.huy@frz.cc> 
Matthias Butz <matze@odinms.de>
Jan Christian Meyer <vimes@odinms.de>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License version 3
as published by the Free Software Foundation. You may not use, modify
or distribute this program under any other version of the
GNU Affero General Public License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.odinms.exttools.maplepcap;

import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Properties;
import javax.swing.JOptionPane;

import net.sf.odinms.client.MapleJob;
import net.sf.odinms.client.MapleStat;
import net.sf.odinms.net.RecvPacketOpcode;
import net.sf.odinms.net.SendPacketOpcode;
import net.sf.odinms.net.world.MapleWorld.WorldStatusType;
import net.sf.odinms.server.MapleItemInformationProvider;
import net.sf.odinms.scripting.npc.NPCConversationManager.NPCDialogType;
import net.sf.odinms.tools.HexTool;
import net.sf.odinms.tools.PropertyTool;
import net.sf.odinms.tools.data.input.ByteArrayByteStream;
import net.sf.odinms.tools.data.input.GenericSeekableLittleEndianAccessor;
import net.sf.odinms.tools.data.input.SeekableLittleEndianAccessor;

/**
 *
 * @author  Raz
 */
public class MaplePacketStructureViewer extends javax.swing.JFrame {

    private static final long serialVersionUID = 4520084963404662491L;
    private static final String NEW_LINE = "\r\n";
    private MaplePacketRecord packetRecord;
    private byte[] packetData;
    private SeekableLittleEndianAccessor slea;
    private StringBuilder builder = new StringBuilder();
    private boolean checkingOpcodes = false;
    private boolean send;

    /** Creates new form MaplePacketStructureViewer */
    public MaplePacketStructureViewer() {
        try {
            javax.swing.UIManager.setLookAndFeel(javax.swing.UIManager.getSystemLookAndFeelClassName());
        } catch (Exception e) {
            e.printStackTrace();
        }
        initComponents();
    }

    public static void main(String args[]) {
        Properties settings = new Properties();
        try {
            FileInputStream fis = new FileInputStream("settings.properties");
            settings = new Properties();
            settings.load(fis);
            fis.close();
        } catch (IOException e) {
            System.out.println("Cannot find: settings.properties");
        }
        PropertyTool propTool = new PropertyTool(settings);
        MaplePacketRecord record = new MaplePacketRecord();
        boolean send = propTool.getSettingByte("PACKET_STRUCTURE_SEND") > 0;
        byte[] data = HexTool.getByteArrayFromHexString(propTool.getSettingStr("PACKET_STRUCTURE_DATA"));
        SeekableLittleEndianAccessor slea = new GenericSeekableLittleEndianAccessor(new ByteArrayByteStream(data));
        record.setDataRecord(true);
        record.setPacketData(data);
        record.setCounter(1);
        record.setDirection(send ? "ToServer" : "ToClient");
        record.setSend(send);
        record.setOpcode(slea.readShort());
        slea.seek(0);
        record.setHeader(propTool.getSettingStr("PACKET_STRUCTURE_HEADERNAME"));

        MaplePacketStructureViewer structureViewer = new MaplePacketStructureViewer();
        structureViewer.setPacketRecord(record);
        structureViewer.setPacketData(data);
        structureViewer.setSend(send);
        structureViewer.setPacketLabelText("Packet: " + record.getHeader());
        structureViewer.setVisible(true);
        structureViewer.anazlyePacket();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        closeButton = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        packetStructureTextArea = new javax.swing.JTextArea();
        copyStructureButton = new javax.swing.JButton();
        packetLabel = new javax.swing.JLabel();
        findOpcodeButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Snow's Packet Structure Viewer");
        setResizable(false);

        closeButton.setText("Close");
        closeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeButtonActionPerformed(evt);
            }
        });

        packetStructureTextArea.setColumns(20);
        packetStructureTextArea.setEditable(false);
        packetStructureTextArea.setRows(5);
        jScrollPane1.setViewportView(packetStructureTextArea);

        copyStructureButton.setText("Copy Structure");
        copyStructureButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                copyStructureButtonActionPerformed(evt);
            }
        });

        packetLabel.setText("Packet:");

        findOpcodeButton.setText("Find Possible Opcodes");
        findOpcodeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findOpcodeButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 424, Short.MAX_VALUE)
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(copyStructureButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(findOpcodeButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(closeButton)
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(packetLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 231, Short.MAX_VALUE)
                        .addGap(203, 203, 203))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(packetLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 237, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(copyStructureButton)
                    .addComponent(findOpcodeButton)
                    .addComponent(closeButton))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
	private void closeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeButtonActionPerformed
        //CLOSE
        setVisible(false);
        dispose();
}//GEN-LAST:event_closeButtonActionPerformed

	private void copyStructureButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_copyStructureButtonActionPerformed
        //COPY STRUCTURE DATA
        StringSelection stringSelection = new StringSelection(packetStructureTextArea.getText());
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(stringSelection, stringSelection);
        JOptionPane.showMessageDialog(null, "Copied structure-data to clipboard", "Information", JOptionPane.INFORMATION_MESSAGE);
}//GEN-LAST:event_copyStructureButtonActionPerformed

    private void findOpcodeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findOpcodeButtonActionPerformed
        builder.setLength(0);
        getPossibleOpcodes(send);
        packetStructureTextArea.setText(builder.toString());
}//GEN-LAST:event_findOpcodeButtonActionPerformed

    public MaplePacketRecord getPacketRecord() {
        return packetRecord;
    }

    public void setPacketRecord(MaplePacketRecord packetRecord) {
        this.packetRecord = packetRecord;
    }

    public byte[] getPacketData() {
        return packetData;
    }

    public void setPacketData(byte[] packetData) {
        this.packetData = packetData;
        slea = new GenericSeekableLittleEndianAccessor(new ByteArrayByteStream(packetData));
    }

    public SeekableLittleEndianAccessor getSlea() {
        return slea;
    }

    public void setSlea(SeekableLittleEndianAccessor slea) {
        this.slea = slea;
    }

    public boolean isSend() {
        return send;
    }

    public void setSend(boolean send) {
        this.send = send;
    }

    public void setPacketLabelText(String s) {
        packetLabel.setText(s);
    }

    public void anazlyePacket() {
        if (slea == null || packetRecord == null || !packetRecord.isDataRecord()) {
            return;
        }
        builder.setLength(0);
        if (send) {
            RecvPacketOpcode opcode = RecvPacketOpcode.getByType(slea.readShort());
            if (opcode.equals(RecvPacketOpcode.UNKNOWN)) {
                getPossibleOpcodes(send);
            } else {
                handleToServer(opcode);
            }
        } else {
            SendPacketOpcode opcode = SendPacketOpcode.getByType(slea.readShort());
            if (opcode.equals(SendPacketOpcode.UNKNOWN)) {
                getPossibleOpcodes(send);
            } else {
                handleToClient(opcode);
            }
        }
        if (slea.available() > 0 && !checkingOpcodes) {
            append(0, "\r\nREMAINING_BYTES - " + slea.available());
        }
        packetStructureTextArea.setText(builder.toString());
    }

    public void getPossibleOpcodes(boolean isSend) {
        checkingOpcodes = true;
        findOpcodeButton.setEnabled(false);
        slea.seek(0);
        slea.readShort();
        if (isSend) {
            ArrayList<RecvPacketOpcode> possibleOpcodesRecv = new ArrayList<RecvPacketOpcode>();
            for (RecvPacketOpcode op : RecvPacketOpcode.values()) {
                try {
                    slea.seek(0);
                    slea.readShort();
                    handleToServer(op);
                    if (slea.available() == 0) {
                        possibleOpcodesRecv.add(op);
                    }
                } catch (Exception e) {
                    //invalid op
                }
            }
            builder.setLength(0);
            append(0, "TO_SERVER");
            for (RecvPacketOpcode recvOp : possibleOpcodesRecv) {
                append(0, "POSSIBLE_OPCODE - " + recvOp.name());
            }
        } else {
            ArrayList<SendPacketOpcode> possibleOpcodesSend = new ArrayList<SendPacketOpcode>();
            for (SendPacketOpcode op : SendPacketOpcode.values()) {
                try {
                    slea.seek(0);
                    slea.readShort();
                    handleToClient(op);
                    if (slea.available() == 0) {
                        possibleOpcodesSend.add(op);
                    }
                } catch (Exception e) {
                    //NOT VALID OP
                }
            }
            builder.setLength(0);
            append(0, "TO_CLIENT");
            for (SendPacketOpcode sendOp : possibleOpcodesSend) {
                append(0, "POSSIBLE_OPCODE - " + sendOp.name());
            }
        }
    }

    public byte appendByte(int level, String name) {
        byte value = slea.readByte();
        append(level, name + " - Byte(1) - " + value);
        return value;
    }

    public byte[] appendBytes(int level, String name, int length) {
        byte[] value = slea.read(length);
        append(level, name + "- Byte[](" + length + ") - " + HexTool.toString(value));
        return value;
    }

    public short appendShort(int level, String name) {
        short value = slea.readShort();
        append(level, name + " - Short(2) - " + value);
        return value;
    }

    public int appendInt(int level, String name) {
        int value = slea.readInt();
        append(level, name + " - Int(4) - " + value);
        return value;
    }

    public long appendLong(int level, String name) {
        long value = slea.readLong();
        append(level, name + " - Long(8) - " + value);
        return value;
    }

    public String appendAsciiString(int level, String name, int length) {
        String value = slea.readAsciiString(length);
        append(level, name + " - AsciiString(" + length + ") - " + value);
        return value;
    }

    public String appendMapleAsciiString(int level, String name) {
        String value = slea.readMapleAsciiString();
        append(level, name + " - MapleAsciiString(" + value.length() + ") - " + value);
        return value;
    }

    public void append(int level, String str) {
        for (int i = 0; i < level; i++) {
            builder.append("  ");
        }
        builder.append(str + NEW_LINE);
    }

    public void handleToClient(SendPacketOpcode opcode) {
        append(0, "HEADER - Short(2) - " + opcode.name() + "(" + HexTool.getOpcodeToString((short) opcode.getValue()) + ")");
        switch (opcode) {
            case PING:
            case FORCED_MAP_EQUIP:
            case CANCEL_TV_SMEGA:
            case LUCKSACK_FAIL:
                //NOTHING
                break;
            case LOGIN_STATUS: {
                int result = appendByte(0, "RESULT");
                if (result == 0) {
                    appendByte(0, "UNK");
                    appendInt(0, "UNK");
                    appendInt(0, "ACCOUNT_ID");
                    appendByte(0, "STATUS_OR_GENDER");
                    appendByte(0, "UNK");
                    appendByte(0, "UNK");
                    appendByte(0, "UNK");
                    appendMapleAsciiString(0, "ACCOUNT_NAME");
                    appendByte(0, "UNK");
                    appendByte(0, "CHAT_BLOCK");
                    appendLong(0, "CHAT_BLOCK_DATE");
                    appendLong(0, "ACCOUNT_CREATE_DATE");
                    appendInt(0, "TOTAL_CHARACTERS");
                } else if (result == 2) {
                    //tempban/permban
                } else {
                    //account blocked
                }
                break;
            }
            case SERVERLIST:
                if (slea.available() == 1) {
                    append(0, "--END_OF_SERVER_LIST");
                    appendByte(0, "END_MARKER");
                } else {
                    append(0, "--SERVER_LIST");
                    appendByte(0, "WORLD_ID");
                    appendMapleAsciiString(0, "WORLD_NAME");
                    int statusType = slea.readByte();
                    append(0, "WORLD_STATUS_TYPE - Byte(1) - " + statusType + "(" + WorldStatusType.getById(statusType).name() + ")");
                    appendMapleAsciiString(0, "EVENT_MESSAGE");
                    appendByte(0, "EXP_RATE_MODIFIER");
                    appendByte(0, "EXP_RATE");
                    appendByte(0, "DROP_RATE_MODIFIER");
                    appendByte(0, "DROP_RATE");
                    appendByte(0, "UNK");
                    int lastChannel = appendByte(0, "LAST_CHANNEL");
                    for (int i = 1; i <= lastChannel; i++) {
                        append(2, "CHANNEL - " + i);
                        appendMapleAsciiString(2, "CHANNEL_NAME");
                        appendInt(2, "CHANNEL_LOAD");
                        appendByte(2, "WORLD_ID");
                        appendShort(2, "CHANNEL_INDEX");
                    }
                    appendShort(0, "TICKS");
                }
                break;
            case SERVERSTATUS:
                appendShort(0, "STATUS");
                break;
            case SERVER_IP: {
                appendShort(0, "TICKS");
                String ipStr = HexTool.getIpStringFromBytes(slea.read(4));
                append(0, "IP_ADDRESS - InetAdress(4) - " + ipStr);
                appendShort(0, "PORT");
                appendInt(0, "CLIENT_ID");
                appendInt(0, "TICKS");
                appendByte(0, "TICKS");
                break;
            }
            case CHANGE_CHANNEL: {
                appendByte(0, "TICKS");
                String ipStr = HexTool.getIpStringFromBytes(slea.read(4));
                append(0, "IP_ADDRESS - InetAdress(4) - " + ipStr);
                appendShort(0, "PORT");
                break;
            }
            case CHANNEL_SELECTED:
                appendShort(0, "TICKS");
                appendByte(0, "TICKS");
                break;
            case SPAWN_NPC_REQUEST_CONTROLLER:
                appendByte(0, "TICKS");
            case SPAWN_NPC:
                appendInt(0, "OBJECT_ID");
                appendInt(0, "NPC_ID");
                appendShort(0, "POS_X");
                appendShort(0, "POS_Y");
                appendByte(0, "FACING_LEFT");
                appendShort(0, "FH");
                appendShort(0, "RX_0");
                appendShort(0, "RX_1");
                appendByte(0, "SHOW");
                break;
            case KILL_MONSTER:
                appendInt(0, "OBJECT_ID");
                appendByte(0, "DEATH_ANIMATION");
                break;
            case FACIAL_EXPRESSION:
                appendInt(0, "CHARACTER_ID");
                appendInt(0, "EXPRESSION_ID");
                break;
            case MOVE_PLAYER:
                appendInt(0, "CHARACTER_ID");
                appendInt(0, "TICKS");
                parseMovement();
                break;
            case CHATTEXT:
                appendInt(0, "CHARACTER_ID");
                appendByte(0, "WHITE_BG");
                appendMapleAsciiString(0, "CHAT_TEXT");
                appendByte(0, "BUBBLE_ONLY");
                break;
            case BUFF_COOLDOWN:
                appendInt(0, "SKILL_ID");
                appendShort(0, "TIME");
                break;
            case REACTOR_DESTROY:
                appendInt(0, "OBJECT_ID");
                appendByte(0, "STATE");
                appendShort(0, "POS_X");
                appendShort(0, "POS_Y");
                break;
            case OPEN_NPC_SHOP:
                appendInt(0, "SHOP_ID");
                int size = appendShort(1, "ITEMS_LENGTH");
                for (int i = 0; i < size; i++) {
                    int itemid = appendInt(2, "ITEM");
                    appendInt(2, "PRICE");
                    if (!MapleItemInformationProvider.isRechargable(itemid)) {
                        appendShort(2, "STACK_SIZE");
                        appendShort(2, "ITEM_BUYABLE");
                    } else {
                        appendShort(2, "TICKS");
                        appendInt(2, "TICKS");
                        appendShort(2, "TICKS");
                        appendShort(2, "SLOT_MAX");
                    }
                }
                break;
            case CONFIRM_SHOP_TRANSACTION:
                appendByte(0, "CODE");
                break;
            case SHOW_SCROLL_EFFECT:
                appendInt(0, "CHARACTER_ID");
                short type = appendShort(0, "SUCCESS_TYPE");
                builder.append("SCROLL_RESULT_ID - Short(2) - " + slea.readShort());
                switch (type) {
                    case 0:
                        append(0, "SCROLL_RESULT - FAIL");
                        break;
                    case 1:
                        append(0, "SCROLL_RESULT - SUCCESS");
                        break;
                    case 256:
                        append(0, "SCROLL_RESULT - CURSED");
                        break;
                }
                appendShort(0, "LEGENDARY_SPIRIT");
                break;
            case REMOVE_PLAYER_FROM_MAP:
                appendInt(0, "CHARACTER_ID");
                break;
            case REMOVE_ITEM_FROM_MAP:
                int animation = appendByte(0, "ANIMATION");
                appendInt(0, "OBJECT_ID");
                if (animation >= 2) {
                    appendInt(0, "CHARACTER_ID");
                    if (slea.available() > 0) {
                        appendByte(0, "PET_INDEX");
                    }
                }
                break;
            case CHAR_NAME_RESPONSE:
                appendMapleAsciiString(0, "CHARACTER_NAME");
                appendByte(0, "NAME_USED");
                break;
            case DELETE_CHAR_RESPONSE:
                appendInt(0, "CHARACTER_ID");
                appendByte(0, "STATE");
                break;
            case CHAR_INFO:
                appendInt(0, "CHARACTER_ID");
                appendByte(0, "LEVEL");
                appendInt(0, "CHARACTER_ID");
                appendByte(0, "LEVEL");
                MapleJob job = MapleJob.getById(slea.readShort());
                append(0, "JOB - Short(2) - " + job.getId() + "(" + job.name() + ")");
                appendShort(0, "FAME");
                appendByte(0, "IS_MARRIED");
                appendMapleAsciiString(0, "GUILD_NAME");
                appendMapleAsciiString(0, "ALLIANCE_NAME");
                appendByte(0, "IS_SELF");
                //TODO REST
                break;
            case SHOW_FOREIGN_EFFECT:
                appendInt(0, "CHARACTER_ID");
                if (slea.available() == 1) {
                    appendByte(0, "EFFECT");
                }
                if (slea.available() > 0) {
                    appendByte(0, "IS_CASTER");
                }
                if (slea.available() == 4) {
                    appendInt(0, "SKILL_ID");
                }
                if (slea.available() == 1) {
                    appendByte(0, "LEVEL");
                }
                break;
            case UPDATE_SKILLS:
                appendByte(0, "TICKS");
                appendShort(0, "TICKS");
                appendInt(0, "SKILL_ID");
                appendInt(0, "LEVEL");
                appendInt(0, "MASTER_LEVEL");
                appendByte(0, "TICKS");
                break;
            case SHOW_QUEST_COMPLETION:
                appendShort(0, "QUEST_ID");
                break;
            case KEYMAP:
                appendByte(0, "TICKS");
                while (slea.available() > 4) {
                    appendByte(1, "BINDING_TYPE");
                    appendInt(1, "BINDING_ACTION");
                }
                break;
            case WHISPER: {
                byte mode = appendByte(0, "COMMAND");
                if (mode == 6) {
                    appendMapleAsciiString(0, "RECIPIENT");
                    appendMapleAsciiString(0, "TEXT");
                } else if (mode == 5) {
                    appendMapleAsciiString(0, "RECIPIENT");
                }
                break;
            }
            case SHOW_MONSTER_HP:
                appendInt(0, "OBJECT_ID");
                appendByte(0, "REMAINING_HP_PERCENT");
                break;
            case ITEM_MERGE_COMPLETE:
            case ITEM_SORT_COMPLETE:
                appendByte(0, "INVENTORY_CHANGED");
                appendByte(0, "INVENTORY_ID");
                break;
            case BOSS_ENV:
                 {
                    byte command = appendByte(0, "COMMAND");
                    switch (command) {
                        case 5:
                            append(0, "--SHOW_BOSS_HP--");
                            appendInt(0, "OBJECT_ID");
                            appendInt(0, "HP");
                            appendInt(0, "MAX_HP");
                            appendByte(0, "TAG_COLOR");
                            appendByte(0, "TAG_BG_COLOR");
                            break;
                        case 2:
                        case 3:
                        case 4:
                        case 6:
                            append(0, "--ENVIRONMENT_CHANGE--");
                            appendMapleAsciiString(0, "VARIABLE");
                            break;
                    }
                }
                break;
            case FAME_RESPONSE:
                 {
                    byte command = appendByte(0, "COMMAND");
                    switch (command) {
                        case 5:
                            append(0, "--RECEIVE_FAME--");
                            appendMapleAsciiString(0, "CHARACTER_NAME");
                            appendByte(0, "MODE");
                            break;
                        case 0:
                            append(0, "--GIVE_FAME--");
                            appendMapleAsciiString(0, "CHARACTER_NAME");
                            appendByte(0, "MODE");
                            appendShort(0, "NEW_FAME");
                            appendShort(0, "TICKS");
                            break;
                        default:
                            append(0, "--FAME_ERROR_MESSAGE--");
                            appendByte(0, "ERROR_ID");
                            break;
                    }
                }
                break;
            case CHARLIST:
                appendByte(0, "TICKS");
                byte characters = appendByte(0, "CHARACTERS");
                for (int i = 0; i < characters; i++) {
                    addCharEntry();
                }
                appendInt(0, "MAX_CHARACTERS");
                break;
            case WARP_TO_MAP:
                appendInt(0, "CHANNEL_INDEX");
                int warpType = appendInt(0, "WARP_TYPE");
                if (warpType == 2) {
                    appendInt(0, "MAP_ID");
                    appendByte(0, "SPAWN_POINT");
                    appendShort(0, "CHARACTER_HP");
                    appendByte(0, "TICKS");
                    appendLong(0, "QUEST_MASK");
                } else if (warpType == 1) {
                    appendByte(0, "UNK");
                    appendShort(0, "UNK");
                    appendInt(0, "RANDOM_SEED_X");
                    appendInt(0, "RANDOM_SEED_Y");
                    appendInt(0, "RANDOM_SEED_Z");
                    appendLong(0, "UNK");
                    addCharStats();
                    appendByte(0, "BUDDYLIST_CAPACITY");
                    addInventoryInfo();
                    addSkillInfo();
                    addQuestInfo();
                    addMiniGameRecordInfo();
                    addCoupleRecord();
                    addFriendRecord();
                    addMarriageRecord();
                    addTeleportRockRecord();
                    addMonsterBookRecord();
                    appendShort(0, "UNK_RECORD_INFO");
                    appendShort(0, "UNK_RECORD_INFO");
                    appendShort(0, "UNK_RECORD_INFO");
                    appendLong(0, "CURRENT_FILETIME");
                }
                break;
            case ZAKUM_SHRINE:
            case HORNTAIL_SHRINE:
                appendByte(0, "TICKS");
                appendInt(0, "TIME_LEFT");
                break;
            case SERVERMESSAGE:
                int messageType = slea.readByte();
                String messageTypeStr = "UNK";
                switch (messageType) {
                    case 0:
                        messageTypeStr = "Blue Text + [Notice]";
                        break;
                    case 1:
                        messageTypeStr = "Popup";
                        break;
                    case 2:
                        messageTypeStr = "Light Blue Background";
                        break;
                    case 3:
                        messageTypeStr = "Megaphone Message";
                        break;
                    case 4:
                        messageTypeStr = "Scolling Marquee Messsage";
                        break;
                    case 5:
                        messageTypeStr = "Pink Text";
                        break;
                    case 6:
                        messageTypeStr = "Blue Text";
                        break;
                }
                append(0, "MESSAGE_TYPE - Byte(1) - " + messageType + " (" + messageTypeStr + ")");

                if (messageType == 4) {
                    byte marker = appendByte(0, "SERVER_MESSAGE_MARKER");
                    if (marker == 1) {
                        appendMapleAsciiString(0, "MESSAGE");
                    }
                } else {
                    appendMapleAsciiString(0, "MESSAGE");
                }

                if (messageType == 3) {
                    appendByte(0, "CHANNEL_INDEX");
                    appendByte(0, "SMEGA_EAR");
                }
                break;
            default:
                if (!checkingOpcodes) {
                    append(0, "Warning: Structure info not added yet");
                }
                break;
        }
    }

    public void handleToServer(RecvPacketOpcode opcode) {
        append(0, "HEADER - Short(2) - " + opcode.name() + "(" + HexTool.getOpcodeToString((short) opcode.getValue()) + ")");
        switch (opcode) {
            case PONG:
            case RELOG:
            case SERVERLIST_REQUEST:
            case SERVERLIST_REREQUEST:
            case ENTER_CASH_SHOP://HAS INT IN PACKET?
            case ENTER_MTS:
            case CLOSE_CHALKBOARD:
            case CANCEL_DEBUFF:
                //NOTHING
                break;
            case LOGIN_PASSWORD:
                appendMapleAsciiString(0, "USERNAME");
                appendMapleAsciiString(0, "PASSWORD");
                appendBytes(0, "UNK", 0x10);
                appendInt(0, "UNK");
                appendByte(0, "UNK");
                appendByte(0, "UNK");
                appendInt(0, "UNK");
                break;
            case CHECK_CHAR_NAME:
                appendMapleAsciiString(0, "PLAYER_NAME");
                break;
            case CHARLIST_REQUEST:
                appendByte(0, "SERVER");
                appendByte(0, "CHANNEL");
                break;
            case DELETE_CHAR:
                appendInt(0, "INT_DATE");
                appendInt(0, "CHARACTER_ID");
                break;
            case REGISTER_PIN:
                appendByte(0, "PIN_STATUS");
                appendMapleAsciiString(0, "PIN");
                break;
            case AFTER_LOGIN: {
                byte c2 = appendByte(0, "C2");
                byte c3 = appendByte(0, "C3");
                if (c2 == 1 && c3 == 1) {
                    append(0, "ACTION - REQUEST_PIN");
                } else if (c2 == 1 && c3 == 0) {
                    append(0, "ACTION - ENTER_PIN");
                    appendInt(0, "UNK");
                    appendMapleAsciiString(0, "PIN");
                }
                break;
            }
            case SERVERSTATUS_REQUEST:
                appendByte(0, "WOPRLD_ID");
                break;
            case CHAR_INFO_REQUEST:
                appendInt(0, "TICK_COUNT");
                appendInt(0, "CHARACTER_ID");
                appendByte(0, "IS_SELF");
                break;
            case CREATE_CHAR:
                //TODO: FIX PACKET, PACKET CHANGED I THINK
                appendMapleAsciiString(0, "NAME");
                appendInt(0, "FACE");
                appendInt(0, "HAIR");
                appendInt(0, "HAIR_COLOR");
                appendInt(0, "SKIN_COLOR");
                appendInt(0, "TOP_EQUIP");
                appendInt(0, "BOTTOM_EQUIP");
                appendInt(0, "WEAPON_EQUIP");
                appendByte(0, "GENDER");
                appendByte(0, "STR");
                appendByte(0, "DEX");
                appendByte(0, "INT");
                appendByte(0, "LUK");
                break;
            case CLIENT_ERROR:
                appendByte(0, "MODE");
                appendMapleAsciiString(0, "ERROR(ENC)");
                break;
            case CHANGE_CHANNEL:
                appendByte(0, "CHANNEL_INDEX");
                appendInt(0, "TICK_COUNT");
                break;
            case COUPON_CODE:
                appendShort(0, "UNK");
                appendMapleAsciiString(0, "COUPON_CODE");
                break;
            case DENY_PARTY_REQUEST:
                appendByte(0, "COMMAND");
                appendMapleAsciiString(0, "NAME_FROM");
                appendMapleAsciiString(0, "NAME_TO");
                break;
            case GIVE_FAME:
                appendInt(0, "RECEIVER_CHARACTER_ID");
                appendByte(0, "FAME_RESULT");
                break;
            case DISTRIBUTE_AP:
                appendInt(0, "TICK_COUNT");
                MapleStat stat = MapleStat.getByValue(slea.readInt());
                append(0, "UPDATED_STAT - Int(4) - " + Integer.toHexString(stat.getValue()).toUpperCase() + "(" + stat.name() + ")");
                break;
            case DISTRIBUTE_SP:
                appendInt(0, "TICK_COUNT");
                appendInt(0, "UPDATED_SKILL");
                break;
            case NPC_TALK:
                appendInt(0, "NPC_OID");
                appendInt(0, "UNK");
                break;
            case NPC_SHOP: {
                byte mode = appendByte(0, "MODE");
                switch (mode) {
                    case 0:
                        append(0, "BUY_ITEM");
                        appendShort(0, "SHOP_SLOT");
                        appendInt(0, "ITEM_ID");
                        appendShort(0, "QUANTITY");
                        break;
                    case 1:
                        append(0, "SELL_ITEM");
                        appendShort(0, "SLOT");
                        appendInt(0, "ITEM_ID");
                        appendShort(0, "QUANTITY");
                        break;
                    case 2:
                        append(0, "RECHARGE");
                        appendShort(0, "SLOT");
                        break;
                }
                break;
            }
            case NPC_TALK_MORE: {
                byte lastMsg = appendByte(0, "LAST_MSG");
                byte action = appendByte(0, "ACTION");
                NPCDialogType dialog = NPCDialogType.getByValue(lastMsg);
                append(0, "DIALOG_TYPE - " + dialog.name());
                if (dialog == NPCDialogType.GET_TEXT && action != 0) {
                    appendMapleAsciiString(0, "RETURN_TEXT");
                } else if (dialog == NPCDialogType.GET_NUMBER && action == 1) {
                    appendInt(0, "SELECTION");
                } else if (dialog == NPCDialogType.SIMPLE && action != 0) {
                    appendInt(0, "SELECTION");
                } else if (dialog == NPCDialogType.STYLE && action == 1) {
                    appendInt(0, "SELECTION");
                }
                break;
            }
            case OBJECT_REQUEST:
                appendInt(0, "MAP_ID");
                appendByte(0, "UNK");
                break;
            case CHANGE_MAP:
                if (slea.available() == 0) {
                    append(0, "RE_ENTERING_SERVER_FROM_CASHSHOP_OR_MTS");
                } else {
                    append(0, "CHANGE_MAPS");
                    appendByte(0, "SOURCE");
                    appendInt(0, "TARGET_ID");
                    appendMapleAsciiString(0, "PORTAL_NAME");
                }
                break;
            case USE_DOOR:
                appendInt(0, "OBJECT_ID");
                appendByte(0, "BACKWARP");
                break;
            case FACE_EXPRESSION:
                int emoteId = slea.readInt();
                append(0, "EMOTE_ID - Int(4) - " + emoteId + "(" + (emoteId + 5159992) + ")");
                break;
            case GENERAL_CHAT:
                appendMapleAsciiString(0, "CHAT_TEXT");
                appendByte(0, "BUBBLE_ONLY");
                break;
            case CHANGE_KEYMAP: {
                int mode = appendInt(0, "MODE");
                if (mode == 0) {
                    int keysChanged = appendInt(0, "KEYS_CHANGED");
                    for (int i = 0; i < keysChanged; i++) {
                        appendInt(1, "KEY");
                        appendByte(1, "TYPE");
                        appendInt(1, "ACTION");

                    }
                }//else set pet potion
                break;
            }
            case ITEM_SORT:
            case ITEM_MERGE:
                appendInt(0, "TICK_COUNT");
                appendByte(0, "INVENTORY_ID");
                break;
            case NPC_ACTION:
                if (slea.available() == 6) {
                    appendInt(0, "UNK");
                    appendShort(0, "UNK");
                } else if (slea.available() > 6) {
                    appendBytes(0, "MOVEMENT_DATA", (int) slea.available() - 9);
                    appendBytes(0, "TICKS", 9);
                }
                break;
            case MESO_DROP:
                appendInt(0, "TICK_COUNT");
                appendInt(0, "MESOS");
                break;
            case AUTO_DISTRIBUTE_AP: {
                int amount = appendInt(0, "AMOUNT");
                for (int i = 0; i < amount; i++) {
                    appendInt(1, "TYPE");
                    appendInt(1, "VALUE");
                }
                break;
            }
            case BBS_OPERATION: {
                byte mode = appendByte(0, "MODE");
                switch (mode) {
                    case 0:
                        append(0, "START_NEW_POST");
                        boolean bEdit = appendByte(0, "B_EDIT") == 1;
                        if (bEdit) {
                            appendInt(0, "LOCAL_THREAD_ID");
                        }
                        appendByte(0, "B_NOTICE");
                        appendMapleAsciiString(0, "TITLE");
                        appendMapleAsciiString(0, "TEXT");
                        break;
                    case 1:
                        append(0, "DELETE_THREAD");
                        appendInt(0, "LOCAL_THREAD_ID");
                        break;
                    case 2:
                        append(0, "LIST_THREADS");
                        appendInt(0, "STARTING_THREAD");
                        break;
                    case 3:
                        append(0, "LIST_THREAD_WITH_REPLY");
                        appendInt(0, "LOCAL_THREAD_ID");
                        break;
                    case 4:
                        append(0, "REPLY");
                        appendInt(0, "LOCAL_THREAD_ID");
                        appendMapleAsciiString(0, "TEXT");
                        break;
                    case 5:
                        append(0, "DELETE_REPLY");
                        appendInt(0, "LOCAL_THREAD_ID");
                        appendInt(0, "REPLY_ID");
                        break;
                }
                break;
            }
            case MOVE_PLAYER:
                appendByte(0, "UNK");
                appendInt(0, "UNK");
                parseMovement();
                break;
            case MOVE_LIFE:
                appendInt(0, "OBJECT_ID");
                appendShort(0, "MOVE_ID");
                appendByte(0, "SKILL_BYTE");
                appendByte(0, "SKILL_1");
                appendByte(0, "SKILL_ID");
                appendByte(0, "SKILL_LEVEL");
                appendShort(0, "SKILL_DELAY");
                appendByte(0, "UNK");
                appendInt(0, "UNK");
                appendShort(0, "START_X");
                appendShort(0, "START_Y");
                parseMovement();
                appendBytes(0, "UNK_EXTRA_BYTES", 9);
                break;
            case MOVE_PET:
                appendInt(0, "PET_ID");
                appendInt(0, "UNK");
                appendShort(0, "POS_X");
                appendShort(0, "POS_Y");
                parseMovement();
                break;
            case MOVE_SUMMON:
                appendInt(0, "OBJECT_ID");
                appendShort(0, "POS_X");
                appendShort(0, "POS_Y");
                parseMovement();
                break;
            case USE_UPGRADE_SCROLL:
                appendInt(0, "TICK_COUNT");
                appendShort(0, "SLOT");
                appendShort(0, "DESTINATION");
                appendShort(0, "WHITE_SCROLL");
                break;
            case USE_SKILLBOOK:
            case USE_SUMMON_BAG:
            case USE_MOUNT_FOOD:
            case USE_PET_FOOD:
            case USE_ITEM:
                appendInt(0, "TICK_COUNT");
                appendShort(0, "SLOT");
                appendInt(0, "ITEM_ID");
                break;
            case USE_ITEMEFFECT:
            case USE_CHAIR:
            case CANCEL_ITEM_EFFECT:
                appendInt(0, "ITEM_ID");
                break;
            case USE_CASH_ITEM:
                appendByte(0, "MODE");
                appendByte(0, "UNK");
                appendInt(0, "ITEM_ID");
                //TODO - HANDLE ALL ITEMS
                break;
            case TAKE_DAMAGE:
                appendInt(0, "UNK");
                byte damageFrom = appendByte(0, "DAMAGE_FROM");
                appendByte(0, "ELEMENT");
                appendInt(0, "DAMAGE");
                if (damageFrom != -2) {
                    appendInt(0, "MONSTER_ID_FROM");
                    appendInt(0, "OBJECT_ID");
                }
                break;
            case SPECIAL_MOVE:
                appendInt(0, "TICK_COUNT");
                appendInt(0, "SKILL_ID");
                appendByte(0, "SKILL_LEVEL");
                if (slea.available() == 4) {
                    appendShort(0, "POS_X");
                    appendShort(0, "POS_Y");
                } else {
                    //TODO (Monster Magnet)
                }
                break;
            case DAMAGE_SUMMON:
                appendInt(0, "SKILL_ID");
                appendByte(0, "UNK");
                appendInt(0, "DAMAGE");
                appendInt(0, "MONSTER_ID_FROM");
                break;
            case DENY_GUILD_REQUEST:
                appendByte(0, "UNK");
                appendMapleAsciiString(0, "FROM_NAME");
                break;
            case SPAWN_PET:
                appendInt(0, "TICK_COUNT");
                appendShort(0, "SLOT");
                appendByte(0, "LEAD");
                break;
            case HEAL_OVER_TIME:
                appendInt(0, "STAT_MASK");
                appendShort(0, "HEAL_HP");
                appendShort(0, "HEAL_MP");
                break;
            case CANCEL_CHAIR: {
                int mode = slea.readShort();
                append(0, "TYPE - Short(2) - " + (mode == -1 ? "CANCEL_CHAIR" : "IN_MAP_CHAIR") + "(" + mode + ")");
                break;
            }
            case CANCEL_BUFF:
                appendInt(0, "SKILL_ID");
                break;
            case BUDDYLIST_MODIFY: {
                byte mode = appendByte(0, "MODE");
                switch (mode) {
                    case 1:
                        append(0, "ADD");
                        appendMapleAsciiString(0, "BUDDY_NAME");
                        appendMapleAsciiString(0, "GROUP_NAME");
                        break;
                    case 2:
                        append(0, "ACCEPT_BUDDY");
                        appendInt(0, "BUDDY_CHARACTER_ID");
                        break;
                    case 3:
                        append(0, "DELETE_BUDDY");
                        appendInt(0, "BUDDY_CHARACTER_ID");
                        break;
                }
                break;
            }
            case GUILD_OPERATION: {
                byte mode = appendByte(0, "MODE");
                switch (mode) {
                    case 2:
                        append(0, "CREATE_GUILD");
                        appendMapleAsciiString(0, "GUILD_NAME");
                        break;
                    case 5:
                        append(0, "INVITE_TO_GUILD");
                        appendMapleAsciiString(0, "NAME");
                        break;
                    case 6:
                        append(0, "ACCEPTED_INVITE");
                        appendInt(0, "GUILD_ID");
                        appendInt(0, "CHARACTER_ID");
                        break;
                    case 7:
                        append(0, "LEAVE_GUILD");
                        appendInt(0, "CHARACTER_ID");
                        appendMapleAsciiString(0, "NAME");
                        break;
                    case 8:
                        append(0, "EXPEL_MEMBER");
                        appendInt(0, "CHARACTER_ID");
                        appendMapleAsciiString(0, "NAME");
                        break;
                    case 0x0D:
                        append(0, "CHANGE_RANK_TITLES");
                        for (int i = 0; i < 5; i++) {
                            appendMapleAsciiString(0, "RANK_TITLE_ " + i);
                        }
                        break;
                    case 0x0E:
                        append(0, "CHANGE_RANK");
                        appendInt(0, "CHARACTER_ID");
                        appendByte(0, "NEW_RANK");
                        break;
                    case 0x0F:
                        append(0, "CHANGE_EMBLEM");
                        appendShort(0, "BACKGROUND");
                        appendByte(0, "BACKGROUND_COLOR");
                        appendShort(0, "LOGO");
                        appendByte(0, "LOGO_COLOR");
                        break;
                    case 0x10:
                        append(0, "CHANGE_NOTICE");
                        appendMapleAsciiString(0, "NEW_NOTICE");
                        break;
                }
                break;
            }
            case CASHSHOP_OPERATION: {
                byte mode = appendByte(0, "MODE");
                switch (mode) {
                    case 3:
                        append(0, "BUY_ITEM");
                        appendByte(0, "CURRENCY");
                        appendInt(0, "SN");
                        break;
                    case 5:
                        append(0, "UPDATE_WISHLIST");
                        for (int i = 0; i < 10; i++) {
                            appendInt(1, "WISHLIST_ITEM_" + i);
                        }
                        break;
                    case 8:
                        append(0, "BUY_CHARACTER_SLOTS");
                        appendByte(0, "UNK");
                        appendInt(0, "CURRENCY");
                        appendInt(0, "SN");
                        break;
                    case 27:
                        append(0, "BUY_CASH_ITEM_COUPLE");
                        appendInt(0, "BIRTHDAY");
                        appendInt(0, "CURRENCY");
                        appendInt(0, "SN");
                        appendMapleAsciiString(0, "PARTER_NAME");
                        appendMapleAsciiString(0, "UNK");
                        break;
                    case 28:
                        append(0, "BUY_CASH_ITEM_PACKAGE");
                        appendByte(0, "UNK");
                        appendInt(0, "CURRENCY");
                        appendInt(0, "SN");
                        break;
                    case 30:
                        append(0, "BUY_CASH_ITEM_REGULAR");
                        appendInt(0, "SN");
                        break;
                }
                break;
            }
            case ITEM_PICKUP:
                appendByte(0, "MODE");
                appendInt(0, "UNK");
                appendShort(0, "POS_X");
                appendShort(0, "POS_Y");
                appendInt(0, "OBJECT_ID");
                break;
            case MOB_TO_MOB_HIT:
                appendInt(0, "DAMAGE_DEALER_OID");
                appendInt(0, "CHARACTER_ID");
                appendInt(0, "DAMAGE_TAKER_OID");
                break;
            case HYPNOTIZE_MOB_TO_MOB_HIT:
                appendInt(0, "DAMAGE_DEALER_OID");
                appendInt(0, "CHARACTER_ID");
                appendInt(0, "DAMAGE_TAKER_OID");
                appendByte(0, "DAMAGE_TYPE");
                appendInt(0, "DAMAGE");
                appendByte(0, "DIRECTION");
                appendShort(0, "DAMAGE_POS_X");
                appendShort(0, "DAMAGE_POS_Y");
                break;
            case MONSTER_BOMB:
                appendInt(0, "MONSTER_OID");
                break;
            case MONSTERBOOK:
                appendInt(0, "CARD_ID");
                break;
            case STORAGE:
                int command = slea.readByte();
                builder.append("COMMAND - Byte(1) - " + command + "(");
                switch (command) {
                    case 4://TAKE OUT
                        append(0, "TAKE OUT)");
                        appendByte(0, "TYPE");
                        appendByte(0, "SLOT");
                        break;
                    case 5://STORE
                        append(0, "STORE)");
                        appendShort(0, "SLOT");
                        appendInt(0, "ITEM_ID");
                        appendShort(0, "QUANTITY");
                        break;
                    case 6://ARRANGE
                        builder.append("ARRANGE)");
                        break;
                    case 7://MESO
                        append(0, "MESOS)");
                        appendInt(0, "MESOS");
                        break;
                    case 8://CLOSE
                        append(0, "CLOSE)");
                        break;
                }
                break;
            default:
                if (!checkingOpcodes) {
                    append(0, "Warning: Structure info not added yet");
                }
                break;
        }
    }

    public void addCharStats() {
        appendInt(0, "CHARACTER_ID");
        appendAsciiString(0, "CHARACTER_NAME", 13);
        appendByte(0, "GENDER");
        appendByte(0, "SKIN_COLOR");
        appendInt(0, "FACE");
        appendInt(0, "HAIR");
        appendInt(0, "TICKS");
        appendInt(0, "TICKS");
        appendLong(0, "TICKS");
        appendLong(0, "TICKS");
        appendByte(0, "LEVEL");
        MapleJob job = MapleJob.getById(slea.readShort());
        append(0, "JOB_ID - Short(2) - " + job.getId() + " (" + job.name() + ")");
        appendShort(0, "STR");
        appendShort(0, "DEX");
        appendShort(0, "INT");
        appendShort(0, "LUK");
        appendShort(0, "HP");
        appendShort(0, "MAX_HP");
        appendShort(0, "MP");
        appendShort(0, "MAX_MP");
        appendShort(0, "AP");
        appendShort(0, "SP");
        appendInt(0, "EXP");
        appendShort(0, "FAME");
        appendInt(0, "UNK");
        appendInt(0, "MAP_ID");
        appendByte(0, "INITIAL_SPAWN_POINT");
    }

    public void addCharLook() {
        appendByte(0, "GENDER");
        appendByte(0, "SKIN_COLOR");
        appendInt(0, "UNK");
        appendInt(0, "FACE");
        appendByte(0, "NOT_MEGAPHONE");
        appendInt(0, "HAIR");
        byte entry = appendByte(0, "ENTRY");
        while (entry != 0xFF) {
            appendByte(1, "SLOT");
            appendInt(1, "ITEM_ID");
            entry = appendByte(0, "NEW_ENTRY");
        }
        entry = appendByte(0, "ENTRY");
        while (entry != 0xFF) {
            appendByte(1, "SLOT");
            appendInt(1, "ITEM_ID");
            entry = appendByte(0, "NEW_ENTRY");
        }
        appendInt(0, "CASH_WEAPON_ID");
        for (int i = 1; i <= 3; i++) {
            appendInt(0, "PET_" + i + "_ITEM_ID");
        }
    }

    public void addCharEntry() {
        addCharStats();
        addCharLook();
        byte rankEnabled = appendByte(0, "RANK_ENABLED");
        if (rankEnabled == 1) {
            appendInt(0, "RANK");
            appendInt(0, "RANK_MOVE");
            appendInt(0, "JOB_RANK");
            appendInt(0, "JOB_RANK_MOVE");
        }

    }

    public void parseMovement() {
        byte numCommands = appendByte(0, "MOVE_COMMANDS");
        for (int i = 0; i < numCommands; i++) {
            byte command = appendByte(1, "COMMAND");
            switch (command) {
                case 0: //NORMAL MOVE
                case 5: //PET MOVE?
                case 17: //FLOAT - 2
                {
                    appendShort(1, "X_POS");
                    appendShort(1, "Y_POS");
                    appendShort(1, "X_WOBBLE");
                    appendShort(1, "Y_WOBBLE");
                    appendShort(1, "UNK");
                    appendByte(1, "NEW_STATE");
                    appendShort(1, "DURATION");
                    break;
                }
                case 1: //JUMPING
                case 2: //JUMPING/KNOCKBACK
                case 6: //FLASH JUMP
                case 13: //STEP BACK
                case 12: //HORNTAIL KNOCKBACK
                case 16: //FLOAT - 1
                {
                    appendShort(1, "X_MOD");
                    appendShort(1, "Y_MOD");
                    appendByte(1, "NEW_STATE");
                    appendShort(1, "DURATION");
                    break;
                }
                case 3:
                case 4: //TELEPORT
                case 7: //ASSUALTER
                case 8: //ASSASINATE
                case 9: //RUSH
                {
                    appendShort(1, "X_POS");
                    appendShort(1, "Y_POS");
                    appendShort(1, "X_WOBBLE");
                    appendShort(1, "Y_WOBBLE");
                    appendByte(1, "NEW_STATE");
                    break;
                }
                case 10: //CHANGE EQUIP
                {
                    appendByte(1, "SLOT");
                    break;
                }
                case 11: //CHAIR
                case 14: //JUMP DOWN - 1
                {

                    appendShort(1, "X_POS");
                    appendShort(1, "Y_POS");
                    appendShort(1, "UNK");
                    appendByte(1, "NEW_STATE");
                    appendShort(1, "DURATION");
                    break;
                }
                case 15: //JUMP DOWN - 2
                {
                    appendShort(1, "X_POS");
                    appendShort(1, "Y_POS");
                    appendShort(1, "X_WOBBLE");
                    appendShort(1, "Y_WOBBLE");
                    appendShort(1, "UNK");
                    appendShort(0, "FH");
                    appendByte(0, "NEW_STATE");
                    appendShort(0, "DURATION");
                    break;
                }
                default: {
                    append(0, "Unknown Movement Command: " + command + " : Ending structure");
                    return;
                }
            }
        }
    }
    
    public void addItemInfo() {
        //TODO
    }

    public void addInventoryInfo() {
        appendInt(0, "MESOS");
        appendByte(0, "EQUIP_SLOTS");
        appendByte(0, "USE_SLOTS");
        appendByte(0, "SETUP_SLOTS");
        appendByte(0, "ETC_SLOTS");
        appendByte(0, "CASH_SLOTS");
        //TODO
    }

    public void addSkillInfo() {
        int skills = appendShort(0, "SKILLS_COUNT");
        for(int i = 0; i < skills; i++) {
            int skill = appendInt(1, "SKILL_ID");
            appendInt(1, "SKILL_LEVEL");
            if (MapleItemInformationProvider.isMasterLevelSkill(skill)) {
                appendInt(1, "MASTER_LEVEL");
            }
        }
        
        int cooldowns = appendShort(0, "COOLDOWNS_COUNT");
        for(int i = 0; i < cooldowns; i++) {
            appendInt(1, "COOLDOWN_KEY");
            appendShort(1, "COOLDOWN_VALUE");
        }
    }

    public void addQuestInfo() {
        int startedQuests = appendShort(0, "QUESTS_STARTED_COUNT");
        for(int i = 0; i < startedQuests; i++) {
            appendShort(1, "QUEST_ID");
            appendMapleAsciiString(1, "QUEST_STRING_VALUE");
        }

        int completedQuests = appendShort(0, "QUESTS_COMPLETED_COUNT");
        for(int i = 0; i < completedQuests; i++) {
            appendShort(1, "QUEST_ID");
            appendLong(1, "QUEST_COMPLETE_FILETIME");
        }
    }

    public void addMiniGameRecordInfo() {
        int records = appendShort(0, "MINIGAME_RECORD_COUNT");
        for(int i = 0; i < records; i++) {
            appendInt(1, "MINIGAME_ID");
            appendInt(1, "MINIGAME_WINS");
            appendInt(1, "MINIGAME_TIES");
            appendInt(1, "MINIGAME_LOSSES");
            appendInt(1, "MINIGAME_POINTS");
        }
    }

    public void addCoupleRecord() {
        int records = appendShort(0, "COUPLE_RECORD_COUNT");
        for(int i = 0; i < records; i++) {
            appendBytes(1, "COUPLE_DATA", 0x21);
        }
    }

    public void addFriendRecord() {
        int records = appendShort(0, "FRIEND_RECORD_COUNT");
        for(int i = 0; i < records; i++) {
            appendBytes(1, "FRIEND_DATA", 0x25);
        }
    }

    public void addMarriageRecord() {
        int records = appendShort(0, "MARRIAGE_RECORD_COUNT");
        for(int i = 0; i < records; i++) {
            appendBytes(1, "MARRIAGE_DATA", 0x30);
        }
    }

    public void addTeleportRockRecord() {
        for(int i = 0; i < 5; i++) {
            appendInt(0, "TELEPORT_MAP_" + i);
        }

        for(int i = 0; i < 10; i++) {
            appendInt(0, "VIP_TELEPORT_MAP_" + i);
        }
    }

    public void addMonsterBookRecord() {
        appendInt(0, "MONSTERBOOK_COVER");
        appendByte(0, "UNK");
        int cards = appendShort(0, "MONSTERBOOK_CARD_COUNT");
        for(int i = 0; i < cards; i++) {
            appendShort(1, "CARD_ID");
            appendByte(1, "CARD_LEVEL");
        }

    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton closeButton;
    private javax.swing.JButton copyStructureButton;
    private javax.swing.JButton findOpcodeButton;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel packetLabel;
    private javax.swing.JTextArea packetStructureTextArea;
    // End of variables declaration//GEN-END:variables
}
